#!/usr/bin/env perl

use warnings;
use strict;

use File::Spec::Functions;
use Cwd qw(abs_path);

{ package RCFiles;
    # import subs we just loaded from the main namespace
    *abs_path = *::abs_path;
    *catfile  = *::catfile;

    our ($__QUIET__) = 0;
    our (@symlinks)  = qw(bashrc gitconfig psqlrc tmux.conf vimrc zshrc);
    our (%settings)  = (
        'alias.full-diff'         => '!$(git root)/setup/git-full-diff.sh',
        'alias.ls-untracked'      => 'ls-files -o --exclude-standard',
        'alias.full-reset'        =>
            '!git reset --hard HEAD && git clean -fx',
        'alias.is-dirty'          =>
            '![ $(git status --porcelain | wc -l) -ne 0 ]',
        'filter.gitconfig.clean'  =>
            '$(git root)/setup/strip-ini-section.pl %f user',
        'filter.gitconfig.smudge' => 'cat',
    );

    predeclared_subs: {
        # pseudo-constants
        sub __success__() { 0 }
        sub __failure__() { 1 }

        # silence-able wrappers to print() and warn()
        sub __print($);
        sub __warn($);

        # consistently-styled messages
        sub __good($);
        sub __bad($);
        sub __die($);

        # run this script again as a subcommand
        sub __exec($);

        # switch to the repository directory consistently
        sub __chdir(;$);
    }

    # TODO: make it confirm successes/failures AFTER actions
    sub relink {
        foreach my $symlink (@symlinks) {
            my ($sympath)  = catfile($ENV{HOME}, ".$symlink");
            my ($realpath) = catfile($ENV{RCDIR}, 'configs', $symlink);
            my ($resolved) = abs_path($sympath);

            next if ($resolved eq $realpath);

            if (-e $resolved) {
                __good "Moving $resolved to $realpath";
                rename($resolved, $realpath) if (-e $resolved);
            }

            __good "Linking $sympath to $realpath";
            symlink($realpath, $sympath);
        }

        __success__
    }

    sub autoconfig {
        my ($changed);
        my ($cwd) = `pwd`;
        chomp($cwd);

        __chdir or return __failure__;

        while (my ($setting, $value) = each(%settings)) {
            my ($curval) = `git config $setting` || '';
            chomp($curval);

            if ($curval ne $value) {
                $changed = 1;

                $ENV{VALUE} = $value;
                `git config $setting "\$VALUE"`;

                if ($?) { __bad "Could not set $setting to $value" }
                else    { __good "Set $setting to $value" }
            }
        }

        # since nothing else would happen when this is called, let people know
        # the command was successful.
        __good 'Existing configuration is valid' unless $changed;

        # try to go back to the former working directory, and warn people if
        # we can't
        __bad "Couldn't return to working directory $cwd" unless chdir($cwd);

        # by now, though, we've done everything we were tasked with doing
        __success__
    }

    sub status {
        __chdir or return __failure__;

        `git is-dirty 2>&1 1>/dev/null`;
        if ($?) {
            __good 'RC Files are locally unmodified';
            __success__
        }
        else {
            __good 'RC Files have been locally modified';
            __good '';
            __good 'To view differences, run:';
            __good '  rcfiles diff';
            __good '';
            __good 'To save changes, run:';
            __good '  rcfiles save';
            __good '';
            __good 'To clear changes, run:';
            __good '  rcfiles reset';

            __failure__
        }
    }

    sub diff {
        __chdir or return __failure__;
        system(qw(git full-diff)) ? __failure__ : __success__
    }

    sub save {
        if (update() == __failure__) {
            return __die "Will not save without updating";
        }

        __chdir or return __failure__;
        my (@untracked) = `git ls-untracked 2>&1`;
        my ($exit) = sub {
            foreach my $untracked (@untracked) {
                chomp($untracked);
                $ENV{TO_REMOVE} = $untracked;
                `git reset HEAD "\$TO_REMOVE"`;
            }
            shift;
        };

        foreach my $untracked (@untracked) {
            chomp($untracked);

            $ENV{TO_ADD} = $untracked;
            `git add "\$TO_ADD" 2>&1`;

            if ($?) {
                __die "Could not add untracked $untracked";
                return $exit->(__failure__);
            }
        }

        system(qw(git commit -a));
        if ($?) {
            __die 'Could not complete commit';
            return $exit->(__failure__);
        }

        `git push 2>&1`;
        if ($?) { __die 'Could not submit updates to remote "origin"' }
        else    { __good 'Submitted changes to remote "origin"'       }
    }

    sub reset {
        __chdir or return __failure__;

        if (do { local $__QUIET__ = 1; status() } == __success__) {
            __good 'Nothing to do';
            return __success__;
        }

        `git full-reset`;
        if ($?) { __die 'Could not reset all local modifications' }
        else    { __good 'RC Files have been reset'               }
    }

    sub update {
        my ($output, $changed);
        __chdir or return __failure__;

        $output  = `git fetch origin 2>&1`;
        if ($?) {
            return __die 'Could not synchronize with remote repository';
        }
        elsif ($output) {
            __good 'Synchronized new changes';
            $changed = 1;
        }

        $output = `git merge --ff-only master origin/master 2>&1`;
        if ($?) {
            return __die "Could not merge with remote changes";
        }
        elsif ($output !~ /Already up-to-date\./) {
            __good 'Merged new changes from "origin"';
            $changed = 1;
        }

        if ($changed) {
            __exec 'autoconfig';
            __exec 'relink';

            __good 'Update process complete';
            __good '';
            __good 'Please run the following to reload configuration for ' .
                   'any active shell sessions:';
            __good '  reshell';
        }
        else {
            __good 'No new updates';
        }
    }

    sub __print($) {
        return if $__QUIET__;
        print shift;
    }

    sub __warn($) {
        return if $__QUIET__;
        warn shift;
    }

    sub __good($) {
        __print "=> @{[ shift ]}\n";
        __success__
    }

    sub __bad($) {
        __warn "@{[ shift ]}\n";
    }

    sub __die($) {
        __warn "fatal: @{[ shift ]}\n";
        __failure__
    }

    sub __exec($) {
        my ($command) = @_;
        my ($perl)    = $^X; # should work well enough...
        my ($rcfiles) = $0;

        system($perl, $rcfiles, $command);

        $? >> 8;
    }

    sub __chdir(;$) {
        my ($nonfatal) = shift;

        unless (chdir($ENV{RCDIR})) {
            my ($errmsg) = "Could not switch to $ENV{RCDIR}";

            $nonfatal ? __bad($errmsg) : __die($errmsg);
            return;
        }

        return 1;
    }

    sub __findsub($) {
        no strict 'refs';
        *{"*@{[ __PACKAGE__ ]}::@{[ shift ]}"}{CODE};
    }

    sub __main__ {
        my ($command) = shift;
        exit __failure__ unless $command;

        my ($subref) = __findsub($command);
        exit __failure__ unless $subref;

        exit($subref->() || __success__);
    }
}

RCFiles::__main__(@ARGV) if ($0 eq __FILE__);
